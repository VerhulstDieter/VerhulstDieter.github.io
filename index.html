<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Slot Machine</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            background: #1e1e1e;
            color: white;
            font-family: monospace;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="slotCanvas"></canvas>

    <script>
        const canvas = document.getElementById('slotCanvas');
        const ctx = canvas.getContext('2d');

        const gridSize = 5;
        const symbolSize = 80;
        const symbols = ['üçí', 'üçã', 'üçä', 'üçâ', '‚≠ê'];
        const symbolBaseScores = {
            'üçí': [10, 20, 30],
            'üçã': [15, 30, 45],
            'üçä': [20, 40, 60],
            'üçâ': [25, 50, 75],
            '‚≠ê': [30, 60, 90]
        };

        let slotGrid = Array.from({ length: gridSize }, () => Array(gridSize).fill('üçí'));
        let highlightedCells = [];
        let coins = 500;
        let spinning = false;
        const spinCost = 25;
        const spinHistory = [];
        let spinCounter = 0;
        let gained = 0;

        // Create audio objects for sounds
        const spinSound = new Audio('spin1.mp3');  // Update with the correct path to your spin sound file
        spinSound.volume = 0.2;
        const winSound = new Audio('win.mp3');  // Add the win sound here
        const loseSound = new Audio('lose.mp3');
        const brokeSound = new Audio('broke.mp3');

        spinSound.loop = true; // Enable looping for the spin sound

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const topMargin = (canvas.height - gridSize * symbolSize) / 2 - 40;
        const leftMargin = (canvas.width - gridSize * symbolSize) / 2;
        const buttonWidth = 150;
        const buttonHeight = 50;
        const buttonX = canvas.width / 2 - buttonWidth / 2;
        const buttonY = topMargin + gridSize * symbolSize + 20;

        function drawRoundedRect(x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    let x = leftMargin + c * symbolSize + symbolSize / 2;
                    let y = topMargin + r * symbolSize + symbolSize / 2;
                    let symbol = slotGrid[r][c];

                    if (highlightedCells.some(cell => cell.r === r && cell.c === c)) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                        ctx.fillRect(leftMargin + c * symbolSize, topMargin + r * symbolSize, symbolSize, symbolSize);
                    }

                    ctx.fillStyle = 'white';
                    ctx.font = '40px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(symbol, x, y);
                }
            }

            // Draw rounded Spin button
            drawRoundedRect(buttonX, buttonY, buttonWidth, buttonHeight, 12);
            ctx.fillStyle = '#28a745';
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = '20px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('SPIN', buttonX + buttonWidth / 2, buttonY + buttonHeight / 2);

            // Draw coins
            ctx.fillStyle = 'white';
            ctx.font = '22px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(`Coins: ${coins}`, canvas.width / 2, topMargin - 20);

            // Draw legend (moved 50px lower)
            const legend = [
                'üçí: 3=10  4=20  5=30',
                'üçã: 3=15  4=30  5=45',
                'üçä: 3=20  4=40  5=60',
                'üçâ: 3=25  4=50  5=75',
                '‚≠ê: 3=30  4=60  5=90'
            ];
            ctx.font = '18px monospace';
            legend.forEach((line, i) => {
                ctx.fillText(line, canvas.width / 2, topMargin + gridSize * symbolSize + 140 + i * 22);
            });

            // Draw history
            const historyX = canvas.width - 250;
            const historyY = 50;
            ctx.textAlign = 'left';
            ctx.font = '16px monospace';
            ctx.fillText(`History:          AVG: ${Math.round(gained/spinCounter)}`, historyX, historyY);

            for (let i = 0; i < Math.min(50, spinHistory.length); i++) {
                ctx.fillText(spinHistory[i], historyX, historyY + 24 + i * 18);
            }
        }

        function randomizeGrid() {
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    slotGrid[r][c] = symbols[Math.floor(Math.random() * symbols.length)];
                }
            }
        }

        function spin() {
            if (spinning || coins < spinCost) {
                brokeSound.play();
                return;
            } 
            coins -= spinCost;
            spinning = true;
            highlightedCells = [];
            randomizeGrid();
            drawGrid();

            // Play the spin sound in a loop
            spinSound.play();

            const spinDuration = Math.random() * 2000 + 2000; // Random between 2 and 4 seconds
            let elapsedTime = 0;
            const spinInterval = setInterval(() => {
                // Shift the grid downward (simulate spinning)
                slotGrid.unshift(slotGrid.pop()); // Move last row to the top
                drawGrid();
                elapsedTime += 100;

                if (elapsedTime >= spinDuration) {
                    clearInterval(spinInterval);
                    finishSpin();
                }
            }, 100); // Shift grid every 100ms
        }

        function finishSpin() {
            // Stop the spin sound after the spin finishes
            spinSound.pause();
            spinSound.currentTime = 0; // Reset sound to start from the beginning next time

            spinCounter++;
            let reward = calculateScore();
            gained += reward;
            coins += reward;

            // Play the win sound if the reward is greater than 0 (indicating a win)
            if (reward > 0) {
                winSound.volume = Math.min(reward/100, 1);
                winSound.play();
            } else {
                loseSound.play();
            }

            spinning = false;
            drawGrid();
        }

        function calculateScore() {
            let score = 0;
            let combos = [];

            function checkLine(line, getCell) {
                let i = 0;
                while (i < line.length) {
                    let count = 1;
                    while (i + count < line.length && line[i] === line[i + count]) {
                        count++;
                    }

                    if (count >= 3) {
                        const symbol = line[i];
                        const base = symbolBaseScores[symbol][count - 3];
                        score += base;
                        combos.push(`${count}x${symbol}`);
                        for (let j = 0; j < count; j++) {
                            const { r, c } = getCell(i + j);
                            highlightedCells.push({ r, c });
                        }
                        i += count;
                    } else {
                        i++;
                    }
                }
            }

            // Horizontal
            for (let r = 0; r < gridSize; r++) {
                checkLine(slotGrid[r], idx => ({ r, c: idx }));
            }

            // Vertical
            for (let c = 0; c < gridSize; c++) {
                let col = slotGrid.map(row => row[c]);
                checkLine(col, idx => ({ r: idx, c }));
            }

            const entry = `#${spinCounter.toString().padStart(2, '0')} +${score.toString().padStart(4)} [${combos.join(', ')}]`;
            spinHistory.unshift(entry);
            if (spinHistory.length > 50) spinHistory.pop();
            return score;
        }

        canvas.addEventListener('click', e => {
            const x = e.clientX;
            const y = e.clientY;
            if (x >= buttonX && x <= buttonX + buttonWidth && y >= buttonY && y <= buttonY + buttonHeight) {
                spin();
            }
        });

        randomizeGrid();
        drawGrid();
    </script>
</body>

</html>
